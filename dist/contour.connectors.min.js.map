{"version":3,"file":"contour.connectors.min.js","sources":["?","../src/scripts/utils.js","../src/scripts/base.js","../src/scripts/connector-base.js","../src/scripts/csv.js","../src/scripts/json.js","../src/scripts/tsv.js","../src/scripts/version.js"],"names":["exports","global","inherit","C","P","F","prototype","__super__","constructor","Contour","extend","dest","current","obj","Array","slice","call","arguments","j","length","key","extendClass","props","staticProps","child","parent","this","hasOwnProperty","apply","connectors","Base","ConnectorBase","initialize","fetch","url","callback","_this","d3","text","data","parse","getDimensions","_data","_headers","dimensions","sampleRow","_","each","header","index","isNaN","trim","push","getMeasures","measures","dimension","_dimension","indexOf","toLowerCase","filter","criteria","_filterSelector","selector","row","newMeasure","name","fn","_newMeasure","_rollup","hashEntry","rows","needsReduce","dimKey","d","i","reduced","gr","reducer","entry","val","measure","extras","isArray","lowerCase","x","map","top","t","_take","bottom","filteredData","rolledRight","r","rolledUp","sortMeasureIndex","_getMeasureIndex","sort","a","b","result","m","_generateSeries","_getDimensionIndex","dimensionData","measureIndex","xVal","tryDate","Date","xData","dataPoint","y","indices","f","extrasObj","Csv","raw","headerRow","splitPattern","split","shift","range","Json","json","keys","keyData","Tsv","version"],"mappings":"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","sourcesContent":[null,"(function () {\n    'use strict';\n\n    function inherit(C, P) {\n        var F = function () {};\n        F.prototype = P.prototype;\n        C.prototype = new F();\n        C.__super__ = P.prototype;\n        C.prototype.constructor = C;\n    }\n\n    /**\n    * Shallow copy of an object\n    */\n    Contour.extend = function (dest /*, var_args*/) {\n        var obj = Array.prototype.slice.call(arguments, 1);\n        var current;\n        for (var j=0; j<obj.length; j++) {\n            if (!(current = obj[j])) continue;\n            for (var key in current) {\n                dest[key] = current[key];\n            }\n        }\n\n        return dest;\n    };\n\n    /**\n    /* Inherit from a class (using prototype borrowing)\n    */\n    Contour.extendClass = function (props, staticProps) {\n        var parent = this;\n        var child;\n\n        child = props && props.hasOwnProperty('constructor') ? props.constructor : function () { return parent.apply(this, arguments); };\n\n        // add static properties to the child constructor function\n        Contour.extend(child, parent, staticProps);\n\n        // associate prototype chain\n        inherit(child, parent);\n\n        // add instance properties\n        if (props) Contour.extend(child.prototype, props);\n\n        // done\n        return child;\n    };\n\n\n})();\n","(function () {\n    'use strict';\n\n    /* define the Contour namespace */\n    Contour = Contour || {};\n    Contour.connectors = Contour.connectors || {};\n\n\n    /* define a base class for all Contour components to inherit common functionality */\n    Contour.Base = function () {};\n    Contour.Base.extend = Contour.extendClass;\n\n})();\n","(function () {\n    'use strict';\n\n    /**\n    * ##Connectors\n    * \n    * Data connectors allow you to connect your visualizations to source data in different formats, including CSV (comma-separated values), TSV (tab-separated values), and JSON.\n    * \n    * All data connectors include several selectors for dimensions and measures, and for filtering data sets.\n    **/\n\n    Contour.connectors.ConnectorBase = Contour.Base.extend({\n        initialize: function () {\n        },\n\n        fetch: function (url, callback) {\n            var _this = this;\n\n            return d3.text(url, function (data) {\n                _this.parse(data);\n                if (callback) callback.call(_this, data);\n            });\n        },\n\n        /**\n        * Returns the list of all posible dimensions for the data set. Dimensions are any non-numeric data.\n        *\n        * ### Example:\n        *\n        *       var csvData = 'quarter,region,cost,revenue,profit\\n2013Q1,North,100,150,50\\n2013Q1,South,200,250,50\\n2013Q2,North,110,150,40\\n2013Q2,South,220,250,30\\n2013Q3,North,90,180,90\\n2013Q3,South,115,180,65\\n2013Q4,North,105,190,85\\n2013Q3,South,90,180,90';\n        *       var csv = new Contour.connectors.Csv(csvData);\n        *\n        *       csv.getDimensions(); // returns array [\"quarter\", \"region\"]\n        *\n        * @function getDimensions\n        * @return {array} Array of dimensions for this data set.\n        */\n        getDimensions: function () {\n            if (!this._data.length) return this._headers[0];\n            var dimensions = [];\n            var sampleRow = this._data[1];\n\n            _.each(this._headers, function (header, index) {\n                if (_.isNaN(+sampleRow[index].trim())) {\n                    dimensions.push(header);\n                }\n\n            }, this);\n\n            return dimensions;\n        },\n\n        /**\n        * Returns the list of all posible measures for the data set.\n        *\n        * ### Example:\n        *\n        *       var csvData = 'quarter,cost,revenue,profit\\n2013Q1,100,150,50\\n2013Q2,110,150,40\\n2013Q3,90,180,90\\n2013Q4,105,190,85'\n        *       var csv = new Contour.connectors.Csv(csvData);\n        *\n        *       csv.getMeasures(); // returns array [\"cost\", \"revenue\", \"profit\"]\n        *\n        * @function getMeasures\n        * @return {array} Array of measures for this data set.\n        */\n        getMeasures: function () {\n            var measures = [];\n            var sampleRow = this._data[1];\n\n            _.each(this._headers, function (header, index) {\n                if (!_.isNaN(+sampleRow[index].trim())) {\n                    measures.push(header);\n                }\n\n            }, this);\n\n            return measures;\n        },\n\n        /**\n        * Specifies the dimension to be used when passing this data set to a Contour visualization. Dimensions are any non-numeric data.\n        *\n        * ### Example:\n        *\n        *       var csvData = 'quarter,region,cost,revenue,profit\\n2013Q1,North,100,150,50\\n2013Q1,South,200,250,50\\n2013Q2,North,110,150,40\\n2013Q2,South,220,250,30\\n2013Q3,North,90,180,90\\n2013Q3,South,115,180,65\\n2013Q4,North,105,190,85\\n2013Q4,South,90,180,90';\n        *       var csv = new Contour.connectors.Csv(csvData);\n        *\n        *       new Contour({\n        *           el: '.myChart',\n        *           xAxis: { title: 'Region' },\n        *           yAxis: { title: 'Profit ($)' }\n        *       })\n        *       .cartesian()\n        *       .column(csv.dimension('region').measure('profit'))\n        *       .render();\n        *\n        * @function dimension\n        * @param {string} string The name of the column to be used as the dimension for the data set.\n        */\n        dimension: function (_) {\n            if(!arguments.length) return this._headers[this._dimension];\n\n            if (typeof _ === 'function') {\n                this._dimension = _;\n            } else {\n                this._dimension = this._headers.indexOf(_.toLowerCase().trim());\n            }\n\n            return this;\n        },\n\n        /**\n        * Specifies a filter for the data set.\n        *\n        * If the parameter is an object, the object will be used as a 'match' for each row in the data set.\n        * For example, `{ region: 'North' }` filters out any rows that do not have 'North' in the column 'region'.\n        *\n        * This can also be a filter function. The filter function will receive each row in the dataset,\n        * and should return true if the row should be included in the final data, or false otherwise.\n        *\n        * ### Example:\n        *\n        *       var csvData = 'quarter,region,cost,revenue,profit\\n2013Q1,North,100,150,50\\n2013Q1,South,200,250,50\\n2013Q2,North,110,150,40\\n2013Q2,South,220,250,30\\n2013Q3,North,90,180,90\\n2013Q3,South,115,180,65\\n2013Q4,North,105,190,85\\n2013Q4,South,90,180,90';\n        *       var csv = new Contour.connectors.Csv(csvData);\n        *\n        *       new Contour({\n        *           el: '.myChart',\n        *           xAxis: { title: 'Quarter' },\n        *           yAxis: { title: 'Profit ($)' }\n        *       })\n        *       .cartesian()\n        *       .column(csv.dimension('quarter').filter({region: 'North'}).measure('profit'))\n        *       .render();\n        *\n        * @function filter\n        * @param {function|object} criteria The function which returns true for each row to include, or the object which matches each row to include.\n        */\n        filter: function (criteria) {\n            if (typeof criteria === 'function') {\n                this._filterSelector = selector;\n            } else {\n\n                this._filterSelector = function (row) {\n                    for(var key in criteria) {\n                        var index = this._headers.indexOf(key);\n                        if (index >= 0 && row[index] !== criteria[key])\n                            return false;\n                    }\n\n                    return true;\n                };\n            }\n\n            return this;\n        },\n\n        newMeasure: function (name, fn) {\n            this._newMeasure = {\n                name: name,\n                fn: fn,\n                index: this._headers.length\n            };\n\n            return this;\n        },\n\n        _rollup: function (data, dimension) {\n            var rows = {};\n            var hashEntry;\n            var needsReduce = false;\n            var _this = this;\n            var dimKey = function (d, i) { return typeof dimension === 'function' ? dimension.call(_this, d, i) : d[dimension]; };\n\n            // map\n            _.each(data, function (d, i) {\n                var key = dimKey(d, i);\n                if (!(hashEntry = rows[key])) {\n                    rows[key] = hashEntry = [];\n                }\n\n                hashEntry.push(d);\n                needsReduce = hashEntry.length > 1;\n            });\n\n            if (!needsReduce) {\n                return data;\n            }\n\n            // reduce\n            var reduced = [];\n            var gr = [];\n\n            var reducer = function (row) {\n                _.each(row, function (entry, i) {\n                    if (i !== dimension && !_.isNaN(+entry)) {\n                        var val = +entry;\n                        gr[i] = (gr[i] || 0) + val;\n                    } else {\n                        gr[i] = gr[i] || entry;\n                    }\n                });\n            };\n\n            for (var key in rows) {\n                gr = [];\n                _.each(rows[key], reducer);\n                reduced.push(gr);\n            }\n\n            return reduced;\n        },\n\n        /**\n        * Returns the data set for the specificied measure.\n        *\n        * ### Example:\n        *\n        *       var csvData = 'quarter,region,cost,revenue,profit\\n2013Q1,North,100,150,50\\n2013Q1,South,200,250,50\\n2013Q2,North,110,150,40\\n2013Q2,South,220,250,30\\n2013Q3,North,90,180,90\\n2013Q3,South,115,180,65\\n2013Q4,North,105,190,85\\n2013Q4,South,90,180,90';\n        *       var csv = new Contour.connectors.Csv(csvData);\n        *\n        *\n        *       new Contour({\n        *           el: '.myChart',\n        *           xAxis: { title: 'Region' },\n        *           yAxis: { title: 'Profit ($)' }\n        *       })\n        *       .cartesian()\n        *       .column(csv.dimension('region').measure('profit'))\n        *       .render();\n        *\n        * @function measure\n        * @param {string|array} name The column name of the measure (case-insensitive). If it is an array,\n        *  each measure will result in a chart series.\n        * @param {array} extras (optional) An array of extra columns to be included in the data set (useful for including extra dimensions).\n        * @return {array} Normalized data set, to be passed to a Contour visualization.\n        */\n        measure: function (name, extras) {\n            name = _.isArray(name) ? name : [name];\n            var lowerCase = function (x) { return x.toLowerCase().trim(); }\n\n            return this.data(_.map(name, lowerCase), _.map(extras, lowerCase));\n        },\n\n        /**\n        * Returns only the top `t` results from the sorted data set. Call this after you have specified dimensions and/or filters but before you have called `.measure()`.\n        *\n        * ### Example:\n        *\n        *       var csvData = 'quarter,region,cost,revenue,profit\\n2013Q1,North,100,150,50\\n2013Q1,South,200,250,50\\n2013Q2,North,110,150,40\\n2013Q2,South,220,250,30\\n2013Q3,North,90,180,90\\n2013Q3,South,115,180,65\\n2013Q4,North,105,190,85\\n2013Q4,South,90,180,90';\n        *       var csv = new Contour.connectors.Csv(csvData);\n        *\n        *       new Contour({\n        *           el: '.myChart',\n        *           xAxis: { title: 'Quarter' },\n        *           yAxis: { title: 'Profit ($)' }\n        *       })\n        *       .cartesian()\n        *           // returns, in order of profitability, the top 3 most profitable quarters in the North region\n        *       .column(csv.dimension('quarter').filter({region: 'North'}).top(3).measure('profit'))\n        *       .render();\n        *\n        * @function top\n        * @param {integer} t The number of results to return.\n        * @return {array} The sorted data set, truncated after `t` results.\n        */\n        top: function (t) {\n            this._take = t;\n            return this;\n        },\n\n        /**\n        * Returns only the bottom `t` results from the sorted data set. Call this after you have specified dimensions and/or filters but before you have called `.measure()`.\n        *\n        * ### Example:\n        *\n        *       var csvData = 'quarter,region,cost,revenue,profit\\n2013Q1,North,100,150,50\\n2013Q1,South,200,250,50\\n2013Q2,North,110,150,40\\n2013Q2,South,220,250,30\\n2013Q3,North,90,180,90\\n2013Q3,South,115,180,65\\n2013Q4,North,105,190,85\\n2013Q4,South,90,180,90';\n        *       var csv = new Contour.connectors.Csv(csvData);\n        *\n        *       new Contour({\n        *           el: '.myChart',\n        *           xAxis: { title: 'Quarter' },\n        *           yAxis: { title: 'Profit ($)' }\n        *       })\n        *       .cartesian()\n        *           // returns, in order of profitability, the bottom 3 most profitable quarters in the North region\n        *       .column(csv.dimension('quarter').filter({region: 'North'}).top(3).measure('profit'))\n        *       .render();\n        *\n        * @function bottom\n        * @param {integer} t The number of results to return.\n        * @return {array} The sorted data set, including only the last `t` results.\n        */\n        bottom: function (t) {\n            this._take = -t;\n            return this;\n        },\n\n        data: function (measures, extras) {\n            measures = _.isArray(measures) ? measures : [measures];\n            var _this = this;\n            var filteredData = this._filterSelector ? _.filter(_this._data, function(row, index) { return _this._filterSelector.call(_this, row, index, _this._headers); }) : this._data;\n            var rolledRight = this._newMeasure ? _.map(filteredData, function (row, index) { var r = row.slice(); r.push(_this._newMeasure.fn.call(_this, row, index, _this._headers)); return r; } ) : filteredData;\n            var rolledUp = this._rollup(rolledRight, this._dimension);\n            var sortMeasureIndex = this._getMeasureIndex(measures[0]);\n\n            if (this._take) {\n                rolledUp.sort(function (a, b) { return +b[sortMeasureIndex] - +a[sortMeasureIndex]; });\n                rolledUp = this._take > 0 ? rolledUp.slice(0, this._take) : rolledUp.slice(this._take);\n            }\n\n            var result = _.map(measures, function (m) { return _this._generateSeries.call(_this, m, rolledUp, extras); });\n\n            return result;\n        },\n\n        _getMeasureIndex: function (measure) {\n            return this._newMeasure && this._newMeasure.name === measure ? this._newMeasure.index : this._headers.indexOf(measure);\n        },\n\n        _getDimensionIndex: function (dimension) {\n            return this._headers.indexOf(dimension);\n        },\n\n        _generateSeries: function (measure, data, extras) {\n            var _this = this;\n            var dimensionData = function (d, i) { return (typeof _this._dimension === 'function') ? _this._dimension.call(_this, d, i) : d[_this._dimension]; };\n            var measureIndex = this._getMeasureIndex(measure);\n            var result = _.map(data, function (d, i) {\n                var xVal = dimensionData(d, i);\n                var tryDate = Date.parse(xVal);\n                var xData = xVal == +xVal ? +xVal : !_.isNaN(tryDate) ? new Date(tryDate) : xVal;\n                var dataPoint = {\n                    x: xData,\n                    y: _.isNaN(+d[measureIndex]) ? d[measureIndex] : +d[measureIndex]\n                };\n\n                if (extras) {\n                    var indices = _.map(extras, function (f) { return _this._getMeasureIndex(f); });\n                    var extrasObj = {};\n                    _.each(indices, function (i,index) {\n                        extrasObj[extras[index]] = d[i];\n                    });\n                    _.extend(dataPoint, extrasObj);\n                }\n\n                return dataPoint;\n            });\n\n            return { name: measure, data: result };\n        }\n    });\n\n})();\n","(function () {\n    'use strict';\n\n    // Return array of string values, or NULL if CSV string not well formed.\n    function CSVtoArray(text) {\n        var re_valid = /^\\s*(?:'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|[^,'\"\\s\\\\]*(?:\\s+[^,'\"\\s\\\\]+)*)\\s*(?:,\\s*(?:'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|[^,'\"\\s\\\\]*(?:\\s+[^,'\"\\s\\\\]+)*)\\s*)*$/;\n        var re_value = /(?!\\s*$)\\s*(?:'([^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*)'|\"([^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*)\"|([^,'\"\\s\\\\]*(?:\\s+[^,'\"\\s\\\\]+)*))\\s*(?:,|$)/g;\n        // Return NULL if input string is not well formed CSV string.\n        if (!re_valid.test(text)) return null;\n        var a = [];                     // Initialize array to receive values.\n        text.replace(re_value, // \"Walk\" the string using replace with callback.\n            function(m0, m1, m2, m3) {\n                // Remove backslash from \\' in single quoted values.\n                if      (m1 !== undefined) a.push(m1.replace(/\\\\'/g, \"'\"));\n                // Remove backslash from \\\" in double quoted values.\n                else if (m2 !== undefined) a.push(m2.replace(/\\\\\"/g, '\"'));\n                else if (m3 !== undefined) a.push(m3);\n                return ''; // Return empty string.\n            });\n        // Handle special case of empty last value.\n        if (/,\\s*$/.test(text)) a.push('');\n        return a;\n    };\n\n    /**\n    * Comma Separated Values Files connector (csv)\n    *\n    * ### Example:\n    *\n    *       var csvData = 'quarter,cost,revenue,profit\\n2013Q1,100,150,50\\n2013Q2,110,150,40\\n2013Q3,90,180,90\\n2013Q4,105,190,85';\n    *       var csv = new Contour.connectors.Csv(csvData);\n    *\n    *       new Contour({\n    *         el: '.myChart',\n    *         xAxis: { title: 'Quarter' },\n    *         yAxis: { title: 'Profit ($)' }\n    *       })\n    *       .cartesian()\n    *       .column(csv.measure('profit'))\n    *       .render();\n    *\n    * @class Contour.connectors.Csv\n    */\n    Contour.connectors.Csv = Contour.connectors.ConnectorBase.extend({\n        constructor: function (raw, headerRow) {\n            headerRow = typeof headerRow === 'undefined' ? true : headerRow;\n            this.parse(raw, headerRow);\n\n            this._dimension = 0;\n\n            return this;\n        },\n\n        splitPattern: /,/,\n\n        parse: function (raw, headerRow) {\n            this._data = [];\n            this._headers = [];\n            if (!raw || !raw.length) return ;\n            var rows = raw.split(/\\r\\n|\\r|\\n/);\n            this._headers = headerRow ? _.map(rows.shift().split(this.splitPattern), function(d) { return d.toLowerCase().trim(); }) : _.range(0, rows[0].length);\n            _.each(rows.filter(function (row) { return row.length; }), function (r) {\n                this._data.push(r.split(this.splitPattern));\n            }, this);\n        }\n    });\n\n})();\n","(function () {\n    'use strict';\n\n    /**\n    * JSON connector\n    *\n    * JSON data is assumed to have the following format:\n    *   `{ \"field1\": [\"a\", \"b\", \"c\"], \"field2\": [1,2,3] }`\n    *\n    * ### Example:\n    *\n    *       var json = '{...}';\n    *       var ds = new Contour.connectors.Json(json);\n    *\n    *       new Contour({\n    *         el: '.myChart',\n    *         xAxis: { title: 'Quarter' },\n    *         yAxis: { title: 'Profit ($)' }\n    *       })\n    *       .cartesian()\n    *       .column(ds.measure('profit'))\n    *       .render();\n    *\n    * @class Contour.connectors.Json\n    */\n    Contour.connectors.Json = Contour.connectors.ConnectorBase.extend({\n        constructor: function (json) {\n            this._dimension = 0;\n            this.parse(json);\n            return this;\n        },\n\n        parse: function (raw) {\n            var keys = _.keys(raw);\n            this._headers = _.map(keys, function (d) { return d.toLowerCase(); }) || [];\n            this._data = [];\n\n            for (var i=0; i<keys.length; i++) {\n                var keyData = raw[keys[i]];\n\n                for (var j=0; j<keyData.length; j++) {\n                    var row = this._data[j] || (this._data[j] = []);\n                    row.push(keyData[j]);\n                }\n            }\n        }\n    });\n\n})();\n","(function () {\n    'use strict';\n\n    /**\n    * Tab Separated Values Files connector (tsv)\n\t*\n\t* ### Example:\n    *\n    *       var tsvData = 'quarter\\tcost\\trevenue\\tprofit\\n2013Q1\\t100\\t150\\t50\\n2013Q2\\t110\\t150\\t40\\n2013Q3\\t90\\t180\\t90\\n2013Q4\\t105\\t190\\t85';\n    *       var tsv = new Contour.connectors.Tsv(tsvData);\n    *\n    *       new Contour({\n    *         el: '.myChart',\n\t*        xAxis: { title: 'Quarter' },\n\t*        yAxis: { title: 'Profit ($)' }\n    *       })\n    *       .cartesian()\n    *       .column(tsv.measure('profit'))\n    *       .render();\n\t*\n    * @class Contour.connectors.Tsv\n    */\n    Contour.connectors.Tsv = Contour.connectors.Csv.extend({\n        splitPattern: /\\t/\n    });\n\n})();\n","Contour.connectors.version = '1.0.1';"]}